package com.github.emulio.scrapers.thegamesdb.client.service

import com.github.emulio.scrapers.thegamesdb.clientAutoGenerated.infrastructure.ByteArrayAdapter
import com.github.emulio.scrapers.thegamesdb.clientAutoGenerated.infrastructure.Serializer
import com.squareup.moshi.FromJson
import com.squareup.moshi.Moshi
import com.squareup.moshi.ToJson
import mu.KotlinLogging
import okhttp3.*
import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.asRequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.File
import java.util.*

class RestRequestService(
        val baseUrl: String
) {

    val logger = KotlinLogging.logger { }

    companion object {
        val ContentType = "Content-Type"
        val Accept = "Accept"
        val JsonMediaType = "application/json"
        val FormDataMediaType = "multipart/form-data"
        val FormUrlEncMediaType = "application/x-www-form-urlencoded"
        val XmlMediaType = "application/xml"

        @JvmStatic
        val client by lazy {
            builder.build()
        }

        @JvmStatic
        val builder: OkHttpClient.Builder = OkHttpClient.Builder()
    }

    fun request(request: RequestConfig, body: Any?) {
        logger.debug { "request: $request; body: $body" }
        val url = buildUrl(request)
        val headers = safeHeaders(request)

        val contentType = headers[ContentType]

//        var requestBuilder : Request.Builder =  when (request.method) {
//            RequestMethod.DELETE -> Request.Builder().url(url).delete()
//            RequestMethod.GET -> Request.Builder().url(url)
//            RequestMethod.HEAD -> Request.Builder().url(url).head()
//            RequestMethod.PATCH -> Request.Builder().url(url).patch(requestBody(body, contentType))
//            RequestMethod.PUT -> Request.Builder().url(url).put(requestBody(body, contentType))
//            RequestMethod.POST -> Request.Builder().url(url).post(requestBody(body, contentType))
//            RequestMethod.OPTIONS -> Request.Builder().url(url).method("OPTIONS", null)
//        }

//        headers.forEach { header -> requestBuilder = requestBuilder.addHeader(header.key, header.value) }
//
//        val realRequest = requestBuilder.build()




    }

//    private inline fun <reified T> requestBody(content: T, mediaType: String = JsonMediaType): RequestBody {
//        return when {
//            content is File -> requestBodyFile(content, mediaType)
//            mediaType == FormDataMediaType || mediaType == FormUrlEncMediaType -> requestBodyFormData(content)
//            mediaType == JsonMediaType -> requestBodyJson(content, mediaType)
////            mediaType == XmlMediaType -> TODO("xml not currently supported.")
//            else -> TODO("requestBody currently only supports JSON, File and FormData body.")
//        }
//    }
//
//    private inline fun <reified T> requestBodyJson(content: T, mediaType: String): RequestBody {
//        return Serializer.moshi.adapter(T::class.java).toJson(content)
//                .toRequestBody(mediaType.toMediaTypeOrNull())
//    }
//
//    private inline fun <reified T> requestBodyFormData(content: T): FormBody {
//        var builder = FormBody.Builder()
//        // content's type *must* be Map<String, Any>
//        @Suppress("UNCHECKED_CAST")
//        (content as Map<String, String>).forEach { key, value ->
//            builder = builder.add(key, value)
//        }
//        return builder.build()
//    }
//
//    private fun requestBodyFile(content: File, mediaType: String): RequestBody {
//        return content.asRequestBody(mediaType.toMediaTypeOrNull())
//    }

//    private inline fun <reified T: Any?> responseBody(body: ResponseBody?, mediaType: String? = JsonMediaType): T? {
//        if (body == null) {
//            return null
//        }
//        val bodyContent = body.string()
//        if (bodyContent.isEmpty()) {
//            return null
//        }
//        return when(mediaType) {
//            JsonMediaType -> Moshi.Builder().add(object {
//                @ToJson
//                fun toJson(uuid: UUID) = uuid.toString()
//                @FromJson
//                fun fromJson(s: String) = UUID.fromString(s)
//            })
//                    .add(ByteArrayAdapter())
//                    .build().adapter(T::class.java).fromJson(bodyContent)
//            else ->  TODO("responseBody currently only supports JSON body.")
//        }
//    }

    private fun safeHeaders(request: RequestConfig): Map<String, String> {
        return request.headers.let {
            val mutableHeaders = it.toMutableMap()

            // TODO: support multiple contentType options here.
            mutableHeaders[ContentType] = (it[ContentType] ?: JsonMediaType).substringBefore(";").toLowerCase()
            mutableHeaders[Accept] = it[Accept] ?: JsonMediaType
            mutableHeaders
        }
    }

    private fun buildUrl(request: RequestConfig): HttpUrl {
        val httpUrl = httpUrl()
        val urlBuilder = httpUrl.newBuilder().addPathSegment(request.path.trimStart('/'))

        request.query.entries.forEach { (key, value) ->
            value.forEach { urlBuilder.addQueryParameter(key, it) }
        }

        val url = urlBuilder.build()
        return url
    }

    private fun httpUrl() = baseUrl.toHttpUrlOrNull() ?: throw IllegalStateException("baseUrl is invalid.")

}

enum class RequestMethod { GET, DELETE, HEAD, OPTIONS, PATCH, POST, PUT }

data class RequestConfig(
    val method: RequestMethod,
    val path: String,
    val headers: Map<String, String> = mapOf(),
    val query: Map<String, List<String>> = mapOf()
)